#-------------------------------------------------------------------------------
# Copyright (c) 2012 University of Illinois, NCSA.
# All rights reserved. This program and the accompanying materials
# are made available under the terms of the 
# University of Illinois/NCSA Open Source License
# which accompanies this distribution, and is available at
# http://opensource.ncsa.illinois.edu/license.html
#-------------------------------------------------------------------------------

#' R Code to convert NetCDF CF met files into SIPNET met files
#'
#' If files already exist in 'Outfolder', the default function is NOT to overwrite them and only
#' gives user the notice that file already exists. If user wants to overwrite the existing files,
#' just change overwrite statement below to TRUE.
#'
#' @export
#' @param in.path location on disk where inputs are stored
#' @param in.prefix prefix of input and output files
#' @param outfolder location on disk where outputs will be stored
#' @param start_date the start date of the data to be downloaded (will only use the year part of the date)
#' @param end_date the end date of the data to be downloaded (will only use the year part of the date)
#' @param overwrite should existing files be overwritten
#' @param verbose should the function be very verbose
#' @importFrom ncdf4 ncvar_get
met2model.SIPNET <- function(in.path, in.prefix, outfolder, start_date, end_date, 
                             overwrite = FALSE, verbose = FALSE, ...) {
  
  PEcAn.utils::logger.info("START met2model.SIPNET")
  start_date <- as.POSIXlt(start_date, tz = "UTC")
  end_date <- as.POSIXlt(end_date, tz = "UTC")
  out.file <- paste(in.prefix, strptime(start_date, "%Y-%m-%d"), 
                    strptime(end_date, "%Y-%m-%d"), 
                    "clim", 
                    sep = ".")
  out.file.full <- file.path(outfolder, out.file)
  
  results <- data.frame(file = out.file.full, 
                        host = fqdn(), 
                        mimetype = "text/csv", 
                        formatname = "Sipnet.climna", 
                        startdate = start_date, 
                        enddate = end_date, 
                        dbfile.name = out.file, 
                        stringsAsFactors = FALSE)
  PEcAn.utils::logger.info("internal results")
  print(results)
  
  if (file.exists(out.file.full) && !overwrite) {
    PEcAn.utils::logger.debug("File '", out.file.full, "' already exists, skipping to next file.")
    return(invisible(results))
  }
  
  ## check to see if the outfolder is defined, if not create directory for output
  if (!file.exists(outfolder)) {
    dir.create(outfolder)
  }
  
  out <- NULL
  
  # get start/end year since inputs are specified on year basis
  start_year <- lubridate::year(start_date)
  end_year <- lubridate::year(end_date)
  
  ## loop over files TODO need to filter out the data that is not inside start_date, end_date
  for (year in start_year:end_year) {
    
    skip <- FALSE
    PEcAn.utils::logger.info(year)
    
    old.file <- file.path(in.path, paste(in.prefix, year, "nc", sep = "."))
    
    if (file.exists(old.file)) {
      ## open netcdf
      nc <- ncdf4::nc_open(old.file)
      
      ## convert time to seconds
      sec <- nc$dim$time$vals
      sec <- udunits2::ud.convert(sec, unlist(strsplit(nc$dim$time$units, " "))[1], "seconds")

      year_days <- PEcAn.utils::days_in_year(year)
      year_secs <- udunits2::ud.convert(year_days, 'days', 'seconds')
      day_secs <- udunits2::ud.convert(1, 'day', 'seconds')

      dt <- year_secs / length(sec)

      tstep <- round(day_secs / dt)
      dt <- day_secs / tstep
      
      ## extract variables
      lat <- ncvar_get(nc, "latitude")
      lon <- ncvar_get(nc, "longitude")
      Tair <- ncvar_get(nc, "air_temperature")  ## in Kelvin
      Qair <- ncvar_get(nc, "specific_humidity")  #humidity (kg/kg)
      ws <- try(ncvar_get(nc, "wind_speed"))
      if (!is.numeric(ws)) {
        U <- ncvar_get(nc, "eastward_wind")
        V <- ncvar_get(nc, "northward_wind")
        ws <- sqrt(U ^ 2 + V ^ 2)
      }
      
      Rain <- ncvar_get(nc, "precipitation_flux")
      # pres <- ncvar_get(nc,'air_pressure') ## in pascal
      SW <- ncvar_get(nc, "surface_downwelling_shortwave_flux_in_air")  ## in W/m2
      
      PAR <- try(ncvar_get(nc, "surface_downwelling_photosynthetic_photon_flux_in_air"))  ## in mol/m2/s
      if (!is.numeric(PAR)) {
        PAR <- SW * 0.45
      }
      
      soilT <- try(ncvar_get(nc, "soil_temperature"))
      if (!is.numeric(soilT)) {
        # approximation borrowed from SIPNET CRUNCEPpreprocessing's tsoil.py
        tau <- 15 * tstep
        filt <- exp(-(1:length(Tair)) / tau)
        filt <- (filt / sum(filt))
        soilT <- udunuts2::ud.convert(convolve(Tair, filt), 'K', 'degC')
      } else {
        soilT <- udunuts2::ud.convert(soilT, 'K', 'degC')
      }
      
      Tair_C <- udunuts2::ud.convert(Tair, 'K', 'degC')
      SVP <- udunits2::ud.convert(get.es(Tair_C), "millibar", "Pa")  ## Saturation vapor pressure
      VPD <- try(ncvar_get(nc, "water_vapor_saturation_deficit"))  ## in Pa
      if (!is.numeric(VPD)) {
        VPD <- SVP * (1 - PEcAn.data.atmosphere::qair2rh(Qair, Tair_C))
      }
      e_a <- SVP - VPD
      VPDsoil <- udunits2::ud.convert(get.es(soilT), "millibar", "Pa") * (1 - PEcAn.data.atmosphere::qair2rh(Qair, soilT))
      
      ncdf4::nc_close(nc)
    } else {
      PEcAn.utils::logger.info("Skipping to next year")
      next
    }
    
    ## build time variables (year, month, day of year)
    nyr <- floor(length(sec) / day_secs / 365 * dt)
    yr <- NULL
    doy <- NULL
    hr <- NULL
    asec <- sec
    for (y in year + 1:nyr - 1) {
      ytmp <- rep(y, year_secs / dt)
      dtmp <- rep(seq_len(year_days), each = day_secs / dt)
      if (is.null(yr)) {
        yr <- ytmp
        doy <- dtmp
        hr <- rep(NA, length(dtmp))
      } else {
        yr <- c(yr, ytmp)
        doy <- c(doy, dtmp)
        hr <- c(hr, rep(NA, length(dtmp)))
      }
      rng <- length(doy) - length(ytmp):1 + 1
      if (!all(rng >= 0)) {
        skip <- TRUE
        PEcAn.utils::logger.warn(paste(year, "is not a complete year and will not be included"))
        break
      }
      asec[rng] <- asec[rng] - asec[rng[1]]
      hr[rng] <- (asec[rng] - (dtmp - 1) * day_secs) / day_secs * 24
    }
    if (length(yr) < length(sec)) {
      rng <- (length(yr) + 1):length(sec)
      if (!all(rng >= 0)) {
        skip <- TRUE
        PEcAn.utils::logger.warn(paste(year, "is not a complete year and will not be included"))
        break
      }
      yr[rng] <- rep(y + 1, length(rng))
      doy[rng] <- rep(1:366, each = day_secs / dt)[1:length(rng)]
      hr[rng] <- rep(seq(0, length = day_secs / dt, by = dt/day_secs * 24), 366)[1:length(rng)]
    }
    if (skip) {
      PEcAn.utils::logger.info("Skipping to next year")
      next
    }
    
    ## 0 YEAR DAY HOUR TIMESTEP AirT SoilT PAR PRECIP VPD VPD_Soil AirVP(e_a) WIND SoilM build data
    ## matrix
    n <- length(Tair)
    tmp <- cbind(rep(0, n), 
                 yr[1:n],
                 doy[1:n], 
                 hr[1:n], 
                 rep(dt / day_secs, n), 
                 Tair_C, 
                 soilT, 
                 PAR * dt,  # mol/m2/hr 
                 Rain * dt, # converts from mm/s to mm
                 VPD, 
                 VPDsoil, 
                 e_a, 
                 ws, # wind
                 rep(0.6, n)) # put soil water at a constant. Don't use, set SIPNET to MODEL_WATER = 1
    
    ## quick error check, sometimes get a NA in the last hr
    hr.na <- which(is.na(tmp[, 4]))
    if (length(hr.na) > 0) {
      tmp[hr.na, 4] <- tmp[hr.na - 1, 4] + dt/day_secs * 24
    }
    
    if (is.null(out)) {
      out <- tmp
    } else {
      out <- rbind(out, tmp)
    }
    
  }  ## end loop over years
  
  if (!is.null(out)) {
    
    ## write output
    write.table(out, out.file.full, quote = FALSE, sep = "\t", row.names = FALSE, col.names = FALSE)
    return(invisible(results))
  } else {
    PEcAn.utils::logger.info("NO MET TO OUTPUT")
    return(invisible(NULL))
  }
} # met2model.SIPNET
